---
parent: rlang1.1.1 トピックス
title: R式のディフューズ
---

{% raw %}

# R式のディフューズ

Rコードの一部がディフューズされるとき、いつもと違いその値は返されません。代わりに値の計算方法を記述する特殊なツリー状オブジェクト中の式を返します。これらのディフューズ済み式は計算済みの値の青写真あるいはレシピと捉えられます。`expr()`の使用により式の計算とディフューズの違いを確認できます。

```r
# `1 + 1`の結果を返します。
1 + 1
#> [1] 2

# 式`1 + 1`を返します。
expr(1 + 1)
#> 1 + 1
```

ディフューズ済み式の評価は[`eval()`](https://rdrr.io/r/base/eval.html)によりいつでも再開できます。（`eval_tidy()`も参照）。

```r
# 式`1 + 1`を返します。
e <- expr(1 + 1)

# `1 + 1`の結果を返します。
eval(e)
#> [1] 2
```

ディフューズ済み式のもっとも一般的な用例はデータマスクにおける評価の再開です。これは式がデータフレームの列を正規オブジェクトのように参照する式を可能とします。

```r
e <- expr(mean(cyl))
eval(e, mtcars)
#> [1] 6.1875
```

## ディフューズ済み式について知るべきでしょうか？

tidyverse使用者が`expr()`で式を手動ディフューズする必要はほとんどありません。[`eval()`](https://rdrr.io/r/base/eval.html)や`eval_tidy()`による式の再開も同様です。代わりにデータマスク関数を呼び出すことで引数のディフューズやデータマスクコンテキストを再開できます。

```r
mtcars %>% dplyr::summarise(
  mean(cyl)  # これはディフューズとデータマスクされます。
)
#> # A tibble: 1 x 1
#>   `mean(cyl)`
#>         <dbl>
#> 1        6.19
```

関数による引数のディフューズでは関数から呼び出された場合とわずかに異なる手順が必要なため、関数による引数のディフューズを知ることは重要です。主な違いは引数をエンブレース演算子`{{`により転送する必要です。データマスク関数は`{{`により正しい式をディフューズできます。

詳細は以下を参照してください。

- データマスク処理とは何で{{はなぜ必要か？
- データマスクプログラミングパターン

## ブービートラップによる比喩

「ディフューズ」という用語はRの評価モデルの比喩に由来します。ご存じの通り、Rは遅延評価を用います。引数は計算が必要となったときのみ評価されます。二つの関数を考えてみます。`ignore()`は引数に何もしません。[`force()`](https://rdrr.io/r/base/force.html)は引数をそのまま返します。

```r
ignore <- function(arg) NULL
force <- function(arg) arg

ignore(warning("boom"))
#> NULL

force(warning("boom"))
#> Warning in force(warning("boom")): boom
```

警告が発生するのは`warning()`引数の評価が実際に*動作*したときです。引数の評価は他の関数へのパスにより連鎖されます。連鎖した関数のどれかが引数を無視する場合、評価の連鎖は中断されます。

```r
f <- function(x) g(x)
g <- function(y) h(y)
h <- function(z) ignore(z)

f(warning("boom"))
#> NULL
```

この点では引数は触った瞬間に爆発（評価）されるブービートラップのようなものです。引数のディフューズはブービートラップのディフューズ（爆発解除）に例えられます。

```r
expr(force(warning("boom")))
#> force(warning("boom"))
```

## ディフューズ済み式の種類

- **呼び出し**：`f(1, 2, 3)`や`1 + 1`のようなベクトル含む新しい値を計算する関数の呼び出し表現。
- **シンボル**：`x`や`df`のような名前付きオブジェクトの表現。オブジェクトが関数またはグローバル環境で定義されたシンボルを指す場合、環境変数と呼びます。オブジェクトがデータフレームの列の場合、データ変数と呼びます。
- **定数**：`1`や`NULL`等。

ディフューズ関数`expr()`を使うことで新しい呼び出しやシンボルオブジェクトを作成できます。

```r
# `foo`と呼ばれるオブジェクトを表すシンボルを作成します。
expr(foo)
#> foo

# `foo`の平均値計算を表す呼び出しを作成します。
expr(mean(foo, na.rm = TRUE))
#> mean(foo, na.rm = TRUE)

# 定数を返します。
expr(1)
#> [1] 1

expr(NULL)
#> NULL
```

ディフューズ以外の方法でもディフューズ済み式は作成できます。次のコードはデータからの組み立てです。

```r
# 文字列からの（ディフューズ済み）シンボル作成
var <- "foo"
sym(var)

# 文字列、シンボル、定数からの（ディフューズ済み）呼び出し作成
call("mean", sym(var), na.rm = TRUE)
```

## ローカル式 vs 関数引数

ディフューズ式には表現が2つあり、rlangでは`expr()`と`enquo()`が対応します。

- 自前のR式のディフューズは`expr()`を使います。
- 自作関数でユーザーの提供した式をディフューズするには`en-`処理を使います。`enquo()`や`enquos()`等です。これらは関数の引数をディフューズします。

## ディフューズと注入

式をディフューズ評価する目的のひとつは`!!`を用いたデータマスキング関数から他の関数への式注入の結合です。以下にディフューズ＆注入パターンを示します。

```r
my_summarise <- function(data, arg) {
  # `arg`中のユーザー式のディフューズ
  arg <- enquo(arg)

  # `arg`に含まれる式を`summarise()`引数の中に注入する。
  data |> dplyr::summarise(mean = mean(!!arg, na.rm = TRUE))
}
```

通常、ディフューズ＆注入はエンブレース演算子`{{`により一手順で実行されます。

```r
my_summarise <- function(data, arg) {
  # エンブレース演算子による一手順のディフューズ＆注入
  data |> dplyr::summarise(mean = mean({{ arg }}, na.rm = TRUE))
}
```

`enquo()`と`!!`の区別はディフューズ済み式をただ渡すよりも複雑な場合に有益です。

## ディフューズ済み引数とquosure

`expr()`と`enquo()`の戻り値をインスペクトする場合、`enquo()`は`expr()`のように生の式を返さないことに注意してください。`enquo()`は式と環境のラッパーであるquosureを返します。

```r
expr(1 + 1)
#> 1 + 1

my_function <- function(arg) enquo(arg)
my_function(1 + 1)
#> <quosure>
#> expr: ^1 + 1
#> env:  global
```

Rが引数の式を正確に評価するには環境の情報が必要です。引数の式が与えられるコンテキストは現在の関数と異なるためです。例えば自作パッケージの関数が[`dplyr::mutate()`](https://dplyr.tidyverse.org/reference/mutate.html)を呼び出す場合、quosureの環境はパッケージの非公開関数がすべて定義された場所を指します。quosureの役割を詳しく知るには「quosureは何でいつ必要なのか？」を参照してください。

## base Rとの比較

ディフューズは他のフレームワークではクォート（quoting）として知られています。

- `expr`は[`base::bquote()`](https://rdrr.io/r/base/bquote.html)と同等です。
- `enquo()`は[`base::substitute()`](https://rdrr.io/r/base/substitute.html)と同等です。ただし後者はquosureではなく式自体を返します。
- `enquos()`と同等な関数はありません。ただし、`eval(substitute(alist(...)))`によりドットを式自体のリストにディフューズできます。

{% endraw %}
