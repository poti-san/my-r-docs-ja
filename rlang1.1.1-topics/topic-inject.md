---
parent: rlang1.1.1 トピックス
title: "`!!`、`!!!`、glue構文による注入"
---

{% raw %}
# `!!`、`!!!`、glue構文による注入

注入演算子はrlangで実装されたRの拡張機能です。これらはRによる処理前にコード断片を変更します。主な2種類のファミリーからなります。

- 動的ドット演算子、`!!!`、`"{"`。

- メタプログラミング演算子`!!`、`{{`、`"{{"`。`!!!`によるスプライシングはメタプログラミングのコンテキストで実行できます。

## ドット注入

通常の`...`とは異なり、動的ドットは注入演算子でプログラムできます。

### `!!!`によるスプライシング

具体例として[rbind()](https://rdrr.io/r/base/cbind.html)のような関数を取り上げます。この関数は`...`でデータを受け取ります。行を結合するにはデータを分割された引数として与えます。

```r
rbind(a = 1:2, b = 3:4)
#>   [,1] [,2]
#> a    1    2
#> b    3    4
```

しかし、行の変数番号をリストに結合していた場合はどうしましょう？　base Rでの解決策は[`do.call()`](https://rdrr.io/r/base/do.call.html)を伴った[`rbind()`](https://rdrr.io/r/base/cbind.html)の実行です。

```r
rows <- list(a = 1:2, b = 3:4)

do.call("rbind", rows)
#>   [,1] [,2]
#> a    1    2
#> b    3    4
```

動的ドットを実装する関数には引数のリストを`...`内に納める組み込み機能があります。これを書くため、`list2()`による`...`の収集で動的ドットを受け取れる[rbind()](https://rdrr.io/r/base/cbind.html)の変種を作成してみましょう。

```r
rbind2 <- function(...) {
  do.call("rbind", list2(...))
}
```

これは[`rbind()`](https://rdrr.io/r/base/cbind.html)のように使えます。

```r
rbind2(a = 1:2, b = 3:4)
#>   [,1] [,2]
#> a    1    2
#> b    3    4
```

`!!!`を用いたリストのスプライシングによる引数のリストも与えられます。

```r
rbind2(!!!rows, c = 5:6)
#>   [,1] [,2]
#> a    1    2
#> b    3    4
#> c    5    6
```

### `"{"`による名前の注入

関連する問題は引数の名前が変数に格納されている場合にも起こります。動的ドットを使えば`"{"`を用いた[glue構文](https://glue.tidyverse.org/)により名前を注入できます。

```r
name <- "foo"

rbind2("{name}" := 1:2, bar = 3:4)
#>     [,1] [,2]
#> foo    1    2
#> bar    3    4

rbind2("prefix_{name}" := 1:2, bar = 3:4)
#>            [,1] [,2]
#> prefix_foo    1    2
#> bar           3    4
```

## メタプログラミング注入

データマスク済み引数は以下の注入演算子に対応しています。`inject()`による明示的な有効化も可能です。

### `{{`によるエンブレース

エンブレース演算子`{{`は関数の引数に特化しています。`{{`は引数として与えられた式をディフューズしてその場で注入します。その後、注入済み引数はデータマスクのような異なるコンテキストで評価されます。

```r
# データ変数を含む関数の引数を{{ }}で囲って注入します。
mean_by <- function(data, by, var) {
  data %>%
    dplyr::group_by({{ by }}) %>%
    dplyr::summarise(avg = mean({{ var }}, na.rm = TRUE))
}

# データ変数`cyl`と`disp`は`group_by()`と`summarise()`により
# 環境変数`by`と`var`へ注入されます。
mtcars %>% mean_by(by = cyl, var = disp)
#> # A tibble: 3 x 2
#>     cyl   avg
#>   <dbl> <dbl>
#> 1     4  105.
#> 2     6  183.
#> 3     8  353.
```

このパターンをさらに学ぶには[データマスクプログラミングパターン](topic-data-mask-programming.md)を参照してください。

### `!!`による注入

引数のリストを注入する`!!!`とは異なり、注入演算子`!!`（発音は「bang-bang」）は単一のオブジェクトを注入します。`!!`を使うひとつの場合は（`<-`で作成された）環境変数による（データフレーム中の）データ変数の代替です。

```r
# 環境変数`var`はデータシンボルオブジェクトを含みます。
# このケースではデータ変数`disp`への参照です（著者注：原文のheightはおそらく誤植）。
var <- data_sym("disp")

# `var`を保持するデータ変数を`summarise()`へ注入します。
mtcars %>%
  dplyr::summarise(avg = mean(!!var, na.rm = TRUE))
#> # A tibble: 1 x 1
#>     avg
#>   <dbl>
#> 1  231.
```

`!!`を使うもうひとつの場合は名前の衝突を避けるための値による変数の注入です。

```r
df <- data.frame(x = 1)

# この名前は`df`の列と衝突します。
x <- 100

# 環境変数を注入します。
df %>%
  dplyr::mutate(x = x / !!x)
#>      x
#> 1 0.01
```

ほとんどの場合に`!!`による注入は不要であることに注意してください。例えば、`.data`と`.env`代名詞は列名や値の注入のより直感的な代替です。

### `!!!`によるスプライス

動的ドットのスプライス演算子`!!!`はメタプログラミングの文脈でも使用されます（データマスク済み引数や`inject()`の内部で）。例えば、上で示した`rbind2()`関数は[`do.call()`](https://rdrr.io/r/base/do.call.html)の代わりに`inject()`を使って再実装できます。

```r
rbind2 <- function(...) {
  inject(rbind(!!!list2(...)))
}
```

ここで２つのことが示されます。`list2()`で`...`を集めることで`rbind2()`の呼び出し側は`!!!`を使えます。`inject()`を使うことで`rbind2()`自身も渡された引数のリストをスプライスに`!!!`を使えます。

## 他の言語における注入

他の言語や計算機科学では注入は**疑似引用（quasiquotation）**として知られています。`expr()`は疑似引用演算子と似ており、`!!`は引用解除演算子です。これらの用語はLisp言語で豊富な歴史を持ち、[Julia](https://docs.julialang.org/en/v1/manual/metaprogramming/)や[Racket](https://docs.racket-lang.org/reference/quasiquote.html)等のモダン言語でも現役です。base Rでは、疑似引用は[`bquote()`](https://rdrr.io/r/base/bquote.html)により実現されます。

rlangと他の言語の主な違いは疑似引用がしばしば明示的でなく暗黙であることです。任意のディフューズ／疑似引用関数（その関数が`enquo0()`のような特殊演算子で引数をディフューズしない限り）で注入演算子を使えます。これは注入／引用解除が明示的でバッククオートでのみ有効化されるLisp言語とは異なっています。

## 関連項目

- [コンテキスト外で注入演算子を使うと何が起こるか？](topic-inject-out-of-context.md)
- 
{% endraw %}
