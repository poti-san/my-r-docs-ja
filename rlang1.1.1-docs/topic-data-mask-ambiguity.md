---
parent: rlang1.1.1-docs
title: データマスクの曖昧さ
---

{% raw %}

# データマスクの曖昧さ

データマスク処理はRの機能であり、環境中のプログラミング変数（環境変数）とデータフレームに格納された静的変数（データ変数）の混在を可能とします。これによりデータフレームの列を現在の環境で定義されたオブジェクトのように参照することが容易にできます。

```r
x <- 100
mtcars %>% dplyr::summarise(mean(disp / x))
#> # A tibble: 1 x 1
#>   `mean(disp/x)`
#>            <dbl>
#> 1           2.31
```

しかし、この便利さはデータ変数と環境変数の曖昧さを引き起こし、衝突の原因となります。

### 列の衝突

次のコードでは環境変数`x`、同じ名前のデータ変数`x`のどちらを参照しているでしょうか？

```r
df <- data.frame(x = NA, y = 2)
x <- 100

df %>% dplyr::mutate(y = y / x)
#>    x  y
#> 1 NA NA
```

列の衝突はデータフレームの外で定義されたオブジェクトと列に同じ名前が存在する状態で使おうとした場合に発生します。

### オブジェクトの衝突

逆の問題は同じ名前のデータ変数と環境変数が存在して、タイプミスをした場合に発生します。

```r
df <- data.frame(foo = "right")
ffo <- "wrong"

df %>% dplyr::mutate(foo = toupper(ffo))
#>     foo
#> 1 WRONG
```

タイプミスばかりではなく、予期せず存在しないデータフレームの列を期待したときも起こります。どちらの場合もデータマスク中に変数が見つけられなければ、Rは周辺環境の変数を探索します。これは期待する動作ではなく、「列が見つからない」エラーによる早期の失敗が望まれます。

### 衝突の抑制

カジュアルなスクリプトやインタラクティブなプログラミングでは、データマスクの曖昧さは解析の開発における素早い繰り返しの成果と比べれば大きな打撃ではありません。しかし、コードの生産やパッケージ関数では、曖昧さは長期的に見て衝突バグを引き起こします。

幸いにも少しばかり冗長なコードを使えば変数のスコープを簡単に明示できます。このトピックはデータマスクにおける曖昧さ問題を解決するために作成された解決策と回避方法を列挙します。

#### `.data`代名詞と`.env`代名詞

データ変数と環境変数の曖昧さをなくす一番簡単な解決策は`.data`代名詞と`.env`代名詞です。

```r
df <- data.frame(x = 1, y = 2)
x <- 100

df %>% dplyr::mutate(y = .data$y / .env$x)
#>   x    y
#> 1 1 0.02
```

これは関数中で特に便利です。与えられるデータフレームは事前に分からず、関数のスコープにおける任意の環境変数は潜在的にマスク列を含む可能性があるためです。

```r
my_rescale <- function(data, var, factor = 10) {
  data %>% dplyr::mutate("{{ var }}" := {{ var }} / factor)
}

# これは成功します。
data.frame(value = 1) %>% my_rescale(value)
#>   value
#> 1   0.1

# なんてことだ
data.frame(factor = 0, value = 1) %>% my_rescale(value)
#>   factor value
#> 1      0   Inf
```

`.env`によりサブセット化された引数はマスク列との不一致が保証されます。

```r
my_rescale <- function(data, var, factor = 10) {
  data %>% dplyr::mutate("{{ var }}" := {{ var }} / .env$factor)
}

# やった！
data.frame(factor = 0, value = 1) %>% my_rescale(value)
#>   factor value
#> 1      0   0.1
```

#### 環境変数の`.data`によるサブセット化

`.data`代名詞は名前―データマスクパターンで使用されるでしょう（データマスクプログラミングパターンを参照）。

```r
var <- "cyl"
mtcars %>% dplyr::summarise(mean = mean(.data[[var]]))
#> # A tibble: 1 x 1
#>    mean
#>   <dbl>
#> 1  6.19
```

この例では環境変数`var`はデータマスク内部で`.data`代名詞にサブセット化して使用されます。与えられたデータフレームが同名の列を含む場合、`var`には列の衝突リスクがあるでしょうか。幸いなことに衝突は発生しません。

```r
var <- "cyl"

mtcars2 <- mtcars
mtcars2$var <- "wrong"

mtcars2 %>% dplyr::summarise(mean = mean(.data[[var]]))
#> # A tibble: 1 x 1
#>    mean
#>   <dbl>
#> 1  6.19
```

`.data[[var]]`の評価は曖昧さのない方法で設定されます。`.data`代名詞は環境変数（データ変数ではなくて）によってのみサブセット化されます。技術的には、`.data`に適用された`[[`は注入演算子のように動作します。`[[`はデータマスク作成のずっと前に評価されます。詳しくは以下の`!!`セクションを参照してください。

#### `!!`による環境変数の注入

`!!`のような注入演算子は曖昧さ問題に関して興味深い性質を持ちます。`!!`はすべてのデータマスク処理ロジックが実行される前に注入オブジェクトまたはその他の式としてコード断片を変更します。変数の「値」を注入したとき、式内でインライン展開されます。Rは値を探すために変数を探す必要がなくなります。次のコードは早期除算の例を示します。除算式内部における環境変数`x`の値注入に`!!`を使っています。

```r
df <- data.frame(x = NA, y = 2)
x <- 100

df %>% dplyr::mutate(y = y / !!x)
#>    x    y
#> 1 NA 0.02
```

注入は曖昧さの問題を解決しますが、`.env`代名詞の使用と比べると少しばかり重い処理です。式中の大きなオブジェクトは予期しない場所で問題を起こすでしょう。例えば、[`traceback()`](https://rdrr.io/r/base/traceback.html)の読みやすさが損なわれる場合があります。

### tidy選択には曖昧さがない

[tidy選択](https://tidyselect.r-lib.org/reference/language.html)はtidyverseパッケージにおける列の選択を最適化するRの方言です。tidy選択を使用する関数は例えば[`dplyr::select()`](https://dplyr.tidyverse.org/reference/select.html)や`tidyr::pivot_longer()`です。データマスク処理とは異なり、tidy選択は曖昧さに襲われません。選択言語はデータマスクのみと環境のみどちらのスコープでも式を評価するように設計されています。次のコードを参照してください。

```r
mtcars %>% dplyr::select(gear:ncol(mtcars))
```

`gear`は選択演算子`:`に与えられたシンボルでスコープはデータマスクのみです。`ncol(mtcars)`のような他のどんな種類の式も任意のデータコンテキストの外側で通常のRコードとして評価されます。これが列の衝突しない理由です。

```r
data <- data.frame(x = 1, data = 1:3)

data %>% dplyr::select(data:ncol(data))
#>   data
#> 1    1
#> 2    2
#> 3    3
```

上記は新しい2つの用語の導入に便利です。tidy選択はデータ式と環境式を区別します。

- `data`はデータ変数を参照するデータ表現です。
- `ncol(data)`は環境変数を参照する環境表現です。

上の2表現の違いを詳しく知るには[tidy選択構文の技術解説](https://tidyselect.r-lib.org/articles/syntax.html)を参照してください。

#### `all_of()`を用いた名前パターン

`all_of()`は関数内で列名を`.data`代名詞のようなデータマスクに紐づけるプログラミングパターンとしてしばしば用いられます。次のコードは簡単な例です。

```r
my_group_by <- function(data, vars) {
  data %>% dplyr::group_by(across(all_of(vars)))
}
```

tidy選択がデータマスクの曖昧さに影響される場合、この関数には列衝突のリスクがあります。ユーザーの与えたデータフレームが`vars`列を含む場合です。しかし、`all_of()`はデータマスクの外側で評価される環境表現なので、この衝突は発生しません。

{% endraw %}
